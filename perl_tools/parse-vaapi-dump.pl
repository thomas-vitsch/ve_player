#!/usr/bin/perl

##
# Copyright (c) 2017,
#      Daan Vreeken <Daan @ VEHosting . nl> - http://VEHosting.nl/
#      All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS `AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

use strict;

# This tool can be used to analyze the dump files generated by Thomas' VAAPI
# library when in 'dump mode'.
#
# Run the tool like this:
#	./parse-vaapi-dump.pl < dump-file-here.bin
#
# The tool will generate readable output on screen and it will generate a
# couple of dump files. The file 'restored.mpeg' should be an MPEG file that
# can be played without (extra) artifacts in e.g. mplayer, or VLC.
#
# The MPEG file that this tool produces can be successfully turned back into a
# dump file using 'convert-mpeg-to-veplayer-dump.pl'.
#


# The following variables can be turned on for extra verbosity.
my $show_iq_matrix_buffers = 0;
my $show_slice_param_buffers = 0;

my $fps = 50;

while (@ARGV) {
	my $arg = shift(@ARGV);
	if (($arg eq '-show-matrixes') ||
	    ($arg eq '-show-iq-matrix-buffers')) {
		$show_iq_matrix_buffers = 1;
		next;
	}
	if (($arg eq '-show-slices') ||
	    ($arg eq '-show-slice-param-buffers')) {
		$show_slice_param_buffers = 1;
		next;
	}
	die "Unhandled argument '${arg}'!";
}

my $time_per_frame = 1 / $fps;
my $is_first_frame = 1;
my $stamp = 0;
my $frame_nr = 0;


my $video_fh;
open($video_fh, '>', 'video.dump');

my $mpeg_dump;
open($mpeg_dump, '>', 'restored.mpeg');
start_mpeg_dump($mpeg_dump);

my %buf_type_str = (
	0 => 'VAPictureParameterBufferType',
	1 => 'VAIQMatrixBufferType',
	4 => 'VASliceParameterBufferType',
	5 => 'VASliceDataBufferType',
);

# See mycme462-mpeg2-encoding.pdf, page 27
my %picture_coding_type_str = (
	1 => 'I',
	2 => 'P',
	3 => 'B',
	4 => 'D',
);

my $last_iq_matrix = '';

my ($surface_id, $buf_type, $buf_size, $num_elem);
my $header;

my @last_slice_info;

my $temporal_reference = 0;

while (1) {
	# Read type+size header.
	read(STDIN, $header, 4 * 4)
	    or last;

        # L = 32bit unsigned value	
	($surface_id, $buf_type, $buf_size, $num_elem) = unpack('LLLL',
	    $header);

	my $buf_name = $buf_type_str{$buf_type};

	printf("surface_id=%d, buf_type=0x%02x, buf_size=%6d, num_elem=%d, ".
	    "name=%s\n", $surface_id, $buf_type, $buf_size, $num_elem,
	    $buf_name);
	
	# Read the specified number of data bytes.
	my $data;
	read(STDIN, $data, $buf_size);
	
	# Show contents of VAPictureParameterBufferType
	if ($buf_type == 0x00) {
		# See https://sourcecodebrowser.com/libva/1.0.4/va_8h.html#struct___v_a_picture_parameter_buffer_m_p_e_g2
		# and: https://sourcecodebrowser.com/libva/1.0.4/va_8h_source.html
		# line 551
		my ($horizontal_size, $vertical_size,
		    $forward_reference_picture, $backward_reference_picture,
		    $picture_coding_type, $f_code,
		    $picture_coding_extension,
		) = unpack('SSIIIII', $data);

		my $frame_type = $picture_coding_type_str{$picture_coding_type};

		printf(" horizontal_size=%d, vertical_size=%d,\n".
		    " forward_reference_picture=0x%x,".
		    " backward_reference_picture=0x%x,\n".
		    " picture_coding_type=%d (=%s frame), f_code=%d,".
		    " picture_coding_extension=%d\n",
		    $horizontal_size, $vertical_size,
		    $forward_reference_picture, $backward_reference_picture,
		    $picture_coding_type,
		    $frame_type, $f_code,
		    $picture_coding_extension);
		
		if ($frame_type eq 'I') {
			# Assume every I frame starts a new GOP.
			$temporal_reference = 0;
			
			start_gop($mpeg_dump, $is_first_frame, $stamp);
			$is_first_frame = 0;
			start_i_frame($mpeg_dump, $temporal_reference);
			printf(" GOP timestamp=%0.3fs (frame_nr=%s)\n", $stamp,
			    $frame_nr);
		} elsif ($frame_type eq 'P') {
			start_p_frame($mpeg_dump, $temporal_reference);
		} else {
			die "Teach me how to dump this frame first!";
		}
		$temporal_reference++;
		$stamp += $time_per_frame;
		$frame_nr++;
	}
	
	# Show contents of VAIQMatrixBufferType
	if (($buf_type == 0x01) && ($show_iq_matrix_buffers)) {
		# See https://sourcecodebrowser.com/libva/1.0.4/va_8h_source.html
		# line 581
		my ($load_intra_quantiser_matrix,
		    $load_non_intra_quantiser_matrix,
		    $load_chroma_intra_quantiser_matrix,
		    $load_chroma_non_intra_quantiser_matrix) =
		    unpack('IIII', $data);
		my @mat1 = unpack('C*', substr($data, 4 * 4 + 0 * 64, 64));
		my @mat2 = unpack('C*', substr($data, 4 * 4 + 1 * 64, 64));
		my @mat3 = unpack('C*', substr($data, 4 * 4 + 2 * 64, 64));
		my @mat4 = unpack('C*', substr($data, 4 * 4 + 3 * 64, 64));
		printf(" load_intra_quantiser_matrix=%d,\n".
		    " load_non_intra_quantiser_matrix=%d,\n".
		    " load_chroma_intra_quantiser_matrix=%d,\n".
		    " load_chroma_non_intra_quantiser_matrix=%d,\n".
		    " mat1: [@mat1],\n".
		    " mat2: [@mat2],\n".
		    " mat3: [@mat3],\n".
		    " mat4: [@mat4]\n",
		    $load_intra_quantiser_matrix,
		    $load_non_intra_quantiser_matrix,
		    $load_chroma_intra_quantiser_matrix,
		    $load_chroma_non_intra_quantiser_matrix);
	}
	
	# Show contents of VASliceParameterBufferType
	if ($buf_type == 0x04) {
		# See https://sourcecodebrowser.com/libva/1.0.4/va_8h_source.html
		# line 594.
		my $nr_of_slices = int($buf_size / (8 * 4));
		if (($nr_of_slices * 8 * 4) != $buf_size) {
			die "Incorrectly sized buffer!";
		}
		if ($show_slice_param_buffers) {
			printf(" slices=%d\n", $nr_of_slices);
		}
		my $cnt;
		@last_slice_info = ();
		for ($cnt = 0; $cnt < $nr_of_slices; $cnt++) {
			my ($slice_data_size, $slice_data_offset,
			    $slice_data_flag, $macroblock_offset,
			    $slice_horizontal_position,
			    $slice_vertical_position, $quantiser_scale_code,
			    $intra_slice_flag) =
			    unpack('IIIIIIII', substr($data, $cnt * 8 * 4, 64));
		
			if ($show_slice_param_buffers) {
			printf(" slice[%d]: size=%d, offset=%d, flag=0x%x,".
			    " macroblock_ofs=%d, hor_pos=%d, vert_pos=%d,".
			    " quantiser_scale_code=%d, intra_slice_flag=%d\n",
			    $cnt,
			    $slice_data_size, $slice_data_offset,
			    $slice_data_flag, $macroblock_offset,
			    $slice_horizontal_position, $quantiser_scale_code,
			    $intra_slice_flag);
			}
			
			# Store slice info so we know how to cut-up the data
			# buffer later on.
			push(@last_slice_info, {
				'offset' => $slice_data_offset,
				'size' => $slice_data_size,
			} );
		}
	}
	
	# Show info about VASliceDataBufferType.
	if ($buf_type == 0x05) {
		printf(" data: %d bytes\n", $buf_size);
		print "\n";
		
		dump_data_buffer($mpeg_dump, $data, \@last_slice_info);
	}
	
	# If it's a VAIQMatrixBufferType, compare it to the last we saw.
	if ($buf_type == 0x01) {
		if (($last_iq_matrix ne '') && ($data ne $last_iq_matrix)) {
			print " IQ matrix changed.\n";
		}
		$last_iq_matrix = $data;
	}

	# If it's video (type==0x05), dump it to a file.
	if ($buf_type == 0x05) {
		print $video_fh $data;
	}
	
}

close($video_fh);
close($mpeg_dump);

exit(0);


sub start_mpeg_dump {
	my ($fh) = @_;
	
	# sequence_header_code (contains width/height, bitrate, etc)
	print $fh dvbsnoop_pkt_dump_to_bin(
		"0000:  00 00 01 b3 78 04 38 36  ff ff f1 60               ....x.86...`"
	);

	# extension_start_code (contains profile, etc)
	print $fh dvbsnoop_pkt_dump_to_bin(
		"  0000:  00 00 01 b5 14 4a 00 01  00 00                     .....J...."
	);
}

sub start_gop {
	my ($fh, $is_closed_gop, $timestamp) = @_;
	
	# extension_start_code (contains matrix info and width/height)
	print $fh dvbsnoop_pkt_dump_to_bin(
		"0000:  00 00 01 b5 21 01 01 01  1e 02 21 c0               ....!.....!."
	);
	
	$timestamp = int($timestamp * $fps);
	my $picture = $timestamp % $fps;
	$timestamp -= $picture;
	$timestamp = int($timestamp / $fps);
	my $secs = $timestamp % 60;
	$timestamp -= $secs;
	$timestamp = int($timestamp / 60);
	my $mins = $timestamp % 60;
	$timestamp -= $mins;
	$timestamp = int($timestamp / 60);
	my $hours = $timestamp;
	
	my $pkt;
	$pkt .= pack('C*', 0x00, 0x00, 0x001, 0xb8,
	    # Guess
	    ($mins >> 4) | (($hours << 3) & 0xff),
	    ($secs >> 3) | (1 << 3) | (($mins << 4) & 0xff),
	    ($picture >> 1) | (($secs << 5) & 0xff),
	    (($picture & 1) << 7) | (($is_closed_gop) ? (1 << 6) : 0),
	);
	print $fh $pkt;
}

sub start_i_frame {
	my ($fh, $temporal_reference) = @_;
	
	# picture_start_code
	#print $fh dvbsnoop_pkt_dump_to_bin(
	#	"0000:  00 00 01 00 00 0f ff f8                            ........"
	#);
	print $fh pack('C*',
		0x00, 0x00, 0x01, 0x00,
		$temporal_reference >> 2,
		(($temporal_reference & 0x03) << 6) | 0x0f,
		0xff, 0xf8
	);
	
	# extension_start_code + Picture Coding Extension
	# (without forward/backward references)
	print $fh dvbsnoop_pkt_dump_to_bin(
		"0000:  00 00 01 b5 8f ff f3 41  80                        .......A."
	);
}

sub start_p_frame {
	my ($fh, $temporal_reference) = @_;
	
	# picture_start_code
	#print $fh dvbsnoop_pkt_dump_to_bin(
	#	"0000:  00 00 01 00 01 57 ff fb  80                        .....W..."
	#);
	print $fh pack('C*',
		0x00, 0x00, 0x01, 0x00,
		$temporal_reference >> 2,
		(($temporal_reference & 0x03) << 6) | 0x17,
		0xff, 0xfb, 0x80
	);

	# extension_start_code + Picture Coding Extension
	# (with forward reference)
	print $fh dvbsnoop_pkt_dump_to_bin(
		"0000:  00 00 01 b5 81 1f f3 41  80                        .......A."
	);
}

sub dump_data_buffer {
	my ($fh, $data, $arr) = @_;
	my $info;
	
	# The data buffer contains slices. Slice them one by one.
	my $slice;
	while ($info = shift(@{ $arr })) {
		$slice = substr($data, $info->{'offset'}, $info->{'size'});
		write_pes_packet($fh, $slice);
	}
}

sub write_pes_packet {
	my ($fh, $data) = @_;
	
	print $fh $data;
}

sub dvbsnoop_pkt_dump_to_bin {
	my ($str) = @_;
	my $line;
	my $blob;
	
	foreach $line (split(/\r?\n/, $str)) {
		# Cut leading/trailing whitespace.
		$line =~ s/^\s*|\s*$//g;
		# Only interested in lines of the form: " 0080: 00 5a 4b ..."
		if ($line !~ /^[0-9a-f]+:/i) {
			next;
		}
		# Cut textual representation at end of line away.
		$line =~ s/\s*\ \ \ .*$//g;
		# Cut everything before first hex digit and after last away.
		$line =~ s/^.*:\ \ |\s*$//g;
		# Convert to binary.
		$line =~ s/\s*([0-9a-f]{2})\s*/chr(hex($1))/ge;
		$blob .= $line;
	}
	return $blob;
}





